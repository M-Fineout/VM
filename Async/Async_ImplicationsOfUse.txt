Introducing the async keyword introduces something called a state machine. Now, understanding the particular implementation of a state machine isn't as important as understanding its purpose. 

The state machine is really there to keep track of the tasks in your current asynchronous context.
 
It's also in charge of executing the continuation and thus giving back the potential results. 

It also ensures that a continuation executes on the correct context, which means that it also handles the context switching. 

And it's also in charge of reporting back the errors that you might be receiving inside your asynchronous operations that you're awaiting. 

Looking in .NET Reflector -- an app that takes the binary and decomplies the application, it shows the IL generated by the compiler.

A state machine is generated for every method that you mark as async, so each method that you have marked as async will be turned into something like this. You can see here that it's using something called the AsyncVoidMethodBuilder, which is, in particular, something that it's using for something that's marked as async void. And then, of course, it's starting this process using the state machine. The state machine, of course, also takes care of things like running the continuation.

Now I also introduced this method called Run here, which is marked as async, returns a Task. It has an await inside of it to await a particular asynchronous operation, which in this case just immediately returns the string Pluralsight. So what do you reckon is going to happen here? The first thing that's interesting is that we now have two state machines.

We have one for the Run method and one for our Search_Click event handler. And, of course, if you look at the signature and then what this method returns, you can see that it returns the state machine's builder's Task, which is a reference to all that ongoing asynchronous operation that's currently going on. 

	Even though async and await introduces overhead, it ensures that the code is awaited and makes it 	potentially easier to change, as you can expand with code in the continuation
--------------------------------------------------------------------------------------------------
However...

See Ex: (this shows how using 3 methods with async, thus creating 3 more stateMachines, could be alleviated by just awaiting the initial call to Run()).

In this case here, we have this method called Run, which in its turn calls Compute, which in its turn calls Load, and when Load has executed all of its processing, it returns the result out of that asynchronous operation. Compute will await Load and get the result and return that, and then Run awaits that asynchronous operation as well and returns the result. And, of course, if we compile this and look at the generated code, it introduces the state machine for Run, Load, and Compute. Now introducing this state machine as we saw introduces complexity, and given this scenario, do we really need to introduce a state machine for each of these different operations? 

Since the async keyword doesn't in fact change the signature of the method, we can persist the signature of the methods and just remove all of the async and await keywords. And then all of a sudden we reduce the complexity that was generated by introducing the async and await keywords. 

Whoever's calling Run should be the one that's awaiting this call. So even though this rule is simple for us to introduce the async and await keywords, whenever we are doing asynchronous operations in our applications, be very cautious about it. Think about the situations that you're working in and if there's a way for you to improve the performance of your application by allowing your caller to take care of that asynchronous operation instead. That could potentially allow you to reduce the amount of complexity generated when you're compiling your code.