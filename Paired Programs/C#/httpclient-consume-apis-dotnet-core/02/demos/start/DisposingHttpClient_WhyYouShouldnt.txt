In the beginning of the course, I mentioned that an HttpClient instance is intended to be reused across requests. Yet, it implements IDisposable, so from that I would conclude that I need to wrap it in a using statement and don't keep it hanging around after a request has been handled. In fact, if you look at Microsoft's documentation for the using statement, it states that as a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement. Because of that, a lot of online samples you'll find will wrap HttpClient in a using statement. 

Even though it's counterintuitive, this is wrong. 

The reason is that when HttpClient is disposed of, the underlying HttpClientHandler is disposed of as well. As we learned in the beginning, it's this handler that's responsible for making the actual requests. By disposing of it, the underlying connection is closed as well. So, when you reinstantiate HttpClient for the next request, a new HttpClientHandler is instantiated as well, and the connection has to be reopened again, and so on. Not only is this slower, it can also lead to not having enough sockets available for opening new connections, as it does take a bit of time to completely close the connection and free up the socket. 

The sockets are in a TIME_WAIT state. That means that nothing will be sent over those connections, but they can still receive packets from the server over them. These are the connections that we opened and closed by disposing of HttpClient. When HttpClient is disposed of, the open connection remains in this state for up to 240 seconds, and this can easily lead to socket exhaustion, which we want to avoid. 

SOLUTION: 

From that, the solution seems obvious. Just reuse the instance by making it static, as we've been doing all along, and we're good to go. Well, not exactly. When we reuse our instance, the connection is reused until the socket is closed; for example, due to a network disruption. But that means that domain name system changes aren't honored, and that's a problem as using a DNS change to switch between different environments, like switching from staging to production, is a common scenario. If the change isn't honored, requests would still go to staging instead of production. Moreover, a lot of Azure Platform as a Service services internally use this. We can work around this by, you guessed it, disposing our instance and test the underlying handler, but that's what we don't want to do. There's another workaround for this, which involves using a service point instance, but since .NET Core 2.1, a better approach exists. Using HttpClientFactory for instance management.

FIXES:

Whenever we use the factory to ask for a client, it will create a new HttpClient instance, but instead of recreating the HttpClientHandler, which is the primary message handler, it takes one from a pool. In case of an HttpClientHandler, it's that one that's used to effectively call the API. So, our factory pools HttpMessageHandler instances and manages their lifetime. A handler is held for 2 minutes by default, so any request for a new HttpClient can share a previously created handler and thus the connection as well. Important here, as long as the handler is still in use, for example, for a long-running request, it remains available. Thanks to this, our issue with too many open connections and sockets is mitigated. The handlers, and thus connections, are reused for about 2 minutes.

DNS CHANGES:

The next issue was responding to DNS changes, and it's the fact that HttpClientHandler instances are only around for about 2 minutes, unless they're in use, that mitigates this issue. Once a new instance of the handler is used, DNS changes are taken into account. The best practice today is just to use the HttpClientFactory because next to solving those issues, it also provides a central location for naming and configuring logical HttpClients. That's a very typical use case when you need to integrate with different APIs from your client. In those cases, you can have multiple HttpClients preconfigured for integrating with those different APIs or microservices. When talking about configuration, that also means that we can configure delegating handlers and implement policies through something like poly.